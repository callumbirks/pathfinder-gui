## Introduction
  I started this project for several reasons. The first being that I have only recently finished learning Java and JavaFX and wanted to gain more experience with the Java language and with the JavaFX framework. The second reason is that I have always loved video games and a pathfinding algorithm is something that is used in many video games. The final reason is because I am a big maths and computer science nerd and enjoy learning the intracacies of different algorithms.
  
  Once I had decided to do this project, I knew that I needed to decide which pathfinding algorithm to utilise. The two main pathfinding algorithms I could remember from my Further Maths A-Level were A* and Djikstra's, and after some brushing up on my knowledge of the two I decided to use A* as it is more efficient and quite suitable for the application I had in mind.
  
## Writing the algorithm
  Before I began this project, the last time I had encountered the A* algorithm was, as mentioned above, during my Further Maths A-Level. Therefore I did need to research the algorithm quite heavily. Thankfully, the [Wikipedia page](https://en.wikipedia.org/wiki/A*_search_algorithm) on the A* algorithm covers it very well and even provides some pseudocode off which one could base their own code. When I was starting out writing my algorithm, I did have to lean heavily on this Wikipedia page and the pseudocode. Although as my understanding of the algorithm improved, I modified it to my own liking and my own requirements.
  
## Explanation of my implementation
### The algorithm itself
  The most instrumental part of my implementation of this algorithm is the Node class. The Node class stores every piece of information about each node in the grid. These pieces of information are; the x and y co-ordinates of the node, the f, g, and h values of the node, the previous node to the current node along the path, the list of the current node's neighbours, and a boolean determining whether the current node is a wall.
  
  The other class in my algorithm is the AStar class. This class only uses static methods, and it holds; the grid (a 2D array of Node objects), the start node, and the end node. Other than the modifications I have made (like keeping all of the information for each node inside of the Node objects themselves rather than inside of separate maps), the algorithm essentially runs in a very similar way to the pseudocode algorithm found on the mentioned Wikipedia page. 
  
  In the AStar class there is an open set, which stores all of the nodes to be tested next, using a [priority queue](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html). The priority queue comparator I have used is the f-value of each node, therefore whenever a node is retrieved from the queue, the node with the lowest f-value in the queue is given. This priority queue ensures that the next node to be tested is always the most optimal (ignoring the walls between the given node and the end node).
  
  The algorithm loops over the open set until it is empty. Within this loop; first the code tests whether the current node in the set is the end node - if it is then the reconstructPath function is called and the resulting path returned, otherwise the code will remove the current node from the open set then check each neighbour of the current node and, as long as the neighbour is not a wall, calculate its f and g values and then add the neighbour to the open set.
  
  If there is no solution for a path between the start node and end node, due to walls completely dividing the two, the algorithm will exhaust every possible node and stop looping over the open set without having constructed a path as there will be no more nodes to test. In this case the function itself simply returns null, but the user of the GUI will not see this and instead will simply not see a path drawn between the start node and the end node as there is not a possible path between the two.
  
### The GUI
  As the algorithm alone is not very useful to an end-user, I wanted to provide some visualisation for the algorithm so that anyone could easily see it in action and potentially set their own start and end nodes and place obstacles in the way. As I have some experience with the JavaFX framework, I decided to use this to develop my GUI. As JavaFX written in pure Java can make for very messy code, I opted to use FXML to design the layout of my application, and CSS for the very few styles I needed to apply.
  
  The GUI is not very complicated, the outermost element is a VBox, which contains a HBox for all the buttons, and a canvas which is the element used to render the grid, walls, path etc. The size of the grid (in rows and columns) is dynamic depending on what the PIXEL_SIZE variable is set to inside of the Controller class. This variable determines how big each square on the grid will be, and then in turn the size of the grid calculated by dividing the size in pixels of the canvas by the PIXEL_SIZE variable.
  
  When I initially wrote the GUI, I was using a timeline to call the render function every 33ms, however this is pointlessly innefficient and so I adapted the program so that it instead called the render function whenever something was updated. For example, when the user changed the start node, drew walls in, or ran the algorithm. The render function loops through every node in the grid, checking what it is and then drawing that node appropriately. i.e. walls are drawn in black, the end node is drawn in red, and each node on the path is drawn in blue. If a node is not one of these things then it is simply cleared. The last thing to be rendered is the grid lines, as these need to be drawn after squares have been cleared - otherwise parts of the grid would be missing.
  
  I have written the application is such a way that the algorithm itself (consisting of the Node and AStar classes) is entirely separable from the GUI. Therefore within the Controller class (the controller for the GUI elements), whenever the algorithm is used, it's methods are simply called and relevant variables passed in. Infact because the AStar class only has one public method (run), in order to be use the algorithm one needs simply just to call that method. However, as the algorithm expects a ready-made grid to be passed in, and values for the start and end nodes, some knowledge of the inner-workings of the classes is unfortunately required in order to implement it. However I am working to change this so that one could utilise the algorithm with knowledge only of the public API.
  
## Conclusion
  In conclusion, I am really pleased with the application I have developed as a result of this project, and I believe I have learnt a lot during the development and bug-fixing of this solution. I am now confident in saying I fully understand how the A* algorithm works, and I have also gained a better understanding of the working of the JavaFX framework, and of general best practices within the Java language - especially in regards to efficiency of a solution.
